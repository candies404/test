name: 镜像同步工作流

on:
  workflow_dispatch:
  schedule: 
    - cron: '0 2 * * *'

jobs:
  docker-sync:
    runs-on: ubuntu-latest
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 规则预处理
        id: setup
        run: |
          CLEANED_RULES=$(echo "${{ vars.SYNC_MAPPINGS }}" | 
            tr ',' '\n' |
            sed -E 's/[[:space:]]+//g; /^$/d' |
            sort -u
          )
          echo "SYNC_RULES<<EOF" >> $GITHUB_ENV
          echo "$CLEANED_RULES" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          echo "=== 有效规则 ($(echo "$CLEANED_RULES" | wc -l) 条) ==="
          echo "$CLEANED_RULES"
      - name: 安装依赖工具
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo jq
      - name: 登录DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: 配置高性能构建环境
        uses: docker/setup-buildx-action@v3
        id: buildx
        with:
          driver: docker-container
          driver-opts: |
            image=moby/buildkit:master
            network=host
          buildkitd-config-inline: |
            [registry."docker.io"]
              mirrors = ["dockerpull.cn"]
            [worker.oci]
              max-parallelism = 4
      - name: 执行智能镜像同步
        env:
          DOCKERHUB_USER: "${{ secrets.DOCKERHUB_USERNAME }}"
        run: |
          export BUILDKIT_PROGRESS=plain
          failed_rules=()
          SYNC_EXECUTED=0
          SYNC_SKIPPED=0
          
          # 重构版架构解析函数
          get_platforms() {
            local raw_data="$1"
            [[ -z "$raw_data" ]] && return
            
            # 使用参考示例的解析逻辑
            if echo "$raw_data" | jq -e '.manifests and (.mediaType | contains("manifest.list"))' >/dev/null; then
              # 处理多架构镜像
              echo "$raw_data" | jq -r '
                [.manifests[] | 
                .platform as $p |
                select(
                  $p.os != null and 
                  $p.architecture != null and 
                  $p.os != "unknown" and 
                  $p.architecture != "unknown"
                ) |
                "\($p.os)/\($p.architecture)" +
                (if $p.variant and $p.variant != "" then "/\($p.variant)" else "" end)
                ] | unique[]'
            else
              # 处理单架构镜像和旧格式
              inspect_info=$(echo "$raw_data" | jq -r '
                {
                  Os: .os // (if .architecture then "linux" else "unknown" end),
                  Architecture: .architecture // "unknown",
                  Variant: (if .variant == "" then null else .variant end)
                }')
              
              os=$(jq -r '.Os' <<< "$inspect_info")
              arch=$(jq -r '.Architecture' <<< "$inspect_info")
              variant=$(jq -r '.Variant' <<< "$inspect_info")
              
              if [[ "$os" != "unknown" && "$arch" != "unknown" ]]; then
                platform="${os}/${arch}"
                [[ "$variant" != "null" ]] && platform+="/$variant"
                echo "$platform"
              fi
            fi | grep -v 'unknown'
          }

          check_image_exists() {
            skopeo inspect "docker://$1" >/dev/null 2>&1
          }

          while IFS= read -r rule; do
            [[ -z "$rule" ]] && continue
            echo "=== 🛠️ 处理规则: $rule ==="
            #======= 参数解析 =======#
            src_image="${rule%%=*}"
            target_spec="${rule#*=}"
            target_spec="${target_spec/#docker.io\//}"
            
            if [[ "$src_image" == *":"* ]]; then
              src_tag="${src_image##*:}"
              src_name="${src_image%:*}"
            else
              src_tag="latest"
              src_name="$src_image"
            fi

            if [[ "$target_spec" == *":"* ]]; then
              target_tag="${target_spec##*:}"
              target_base="${target_spec%:*}"
            else
              target_base="$target_spec"
              target_tag="$src_tag"
            fi

            [[ ! "$target_base" == *"/"* ]] && target_base="$DOCKERHUB_USER/$target_base"
            final_spec="$target_base:$target_tag"
            
            #======= 架构分析 =======#
            echo "🔍 校验源镜像 $src_image ..."
            if ! raw_src_data=$(skopeo inspect --raw "docker://$src_image" 2>&1); then
              echo "❌ 镜像检查失败：$raw_src_data" 
              failed_rules+=("$rule")
              continue
            fi
            
            src_platforms=$(get_platforms "$raw_src_data")
            if [[ -z "$src_platforms" ]]; then
              echo "❌ 无法解析有效架构"
              failed_rules+=("$rule")
              continue
            fi
            
            echo "🔎 源镜像支持架构 ($(echo "$src_platforms" | wc -w))："
            echo "$src_platforms" | sed 's/^/  ➤ /'

            #======= 目标镜像分析 =======#
            echo "✳️ 校验目标镜像 $final_spec ..."
            if check_image_exists "$final_spec"; then
              raw_target_data=$(skopeo inspect --raw "docker://$final_spec")
              target_platforms=$(get_platforms "$raw_target_data")
            else
              target_platforms=""
              echo "⚠️ 目标镜像不存在"
            fi

            [[ -n "$target_platforms" ]] && \
              echo "📦 当前目标架构 ($(echo "$target_platforms" | wc -w || echo 0))：" && \
              echo "$target_platforms" | sed 's/^/  ➤ /'

            #======= 同步策略 =======#
            missing_platforms=$(comm -23 <(echo "$src_platforms" | sort) <(echo "${target_platforms:-}" | sort))
            
            if [[ -z "$target_platforms" ]]; then
              echo "🆕 初始化目标镜像..."
              timeout 300 docker buildx imagetools create -t "$final_spec" "$src_image" || {
                echo "❌ 初始化失败"; failed_rules+=("$rule"); continue
              }
              SYNC_EXECUTED=$((SYNC_EXECUTED+1))
            elif [[ -n "$missing_platforms" ]]; then
              echo "🔄 缺失架构 ($(wc -l <<< "$missing_platforms") 种)"
              echo "$missing_platforms" | sed 's/^/  ➤ /'
              timeout 300 docker buildx imagetools create -t "$final_spec" "$src_image" --append || {
                echo "⚡ 增量失败，尝试覆盖..."
                timeout 300 docker buildx imagetools create -t "$final_spec" "$src_image" --force
              }
              SYNC_EXECUTED=$((SYNC_EXECUTED+1))
            else
              echo "⏭️ 所有架构已存在"
              SYNC_SKIPPED=$((SYNC_SKIPPED+1))
            fi

            #======= 结果验证 =======#
            final_platforms=$(get_platforms "$(skopeo inspect --raw "docker://$final_spec")")
            missing_check=$(comm -23 <(echo "$src_platforms" | sort) <(echo "$final_platforms" | sort))
            
            echo "✅ 最终校验："
            if [[ -n "$missing_check" ]]; then
              echo "❌ 缺失架构 ($(wc -l <<< "$missing_check"))"
              echo "$missing_check" | sed 's/^/  ▸ /'
              failed_rules+=("$rule")
            else
              echo "✔️ 同步完成"
            fi
            echo "─────────────────────────────────────"
          done <<< "$SYNC_RULES"

          #======= 生成报告 =======#
          total_rules=$(echo "$SYNC_RULES" | wc -l | tr -d ' ')
          echo "📊=== 执行报告 ==="
          echo "🔢 规则总数 | $total_rules"
          echo "🟩 成功同步 | $SYNC_EXECUTED"
          echo "🟨 跳过同步 | $SYNC_SKIPPED"
          echo "🟥 失败规则 | ${#failed_rules[@]}"
          if ((${#failed_rules[@]} > 0)); then
            echo "🔥 失败规则列表："
            printf "  ‼️ %s\n" "${failed_rules[@]}"
            exit 1
          fi
