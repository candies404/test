name: 镜像同步工作流

on:
  workflow_dispatch:
  schedule:
    - cron: '0 2 * * *'

jobs:
  docker-sync:
    runs-on: ubuntu-latest
    steps:
    - name: 检出代码
      uses: actions/checkout@v4

    - name: 规则预处理
      id: setup
      run: |
        # 清理输入规则（优化空格处理）
        CLEANED_RULES=$(echo "${{ vars.SYNC_MAPPINGS }}" |
          tr '\n' ',' |  # 换行转逗号
          sed -E 's/[[:space:]]+//g; s/,+/ /g; s/^ | $//g' |  # 合并冗余空格和逗号
          tr ' ' '\n' |  # 空格转回车
          grep -v '^$'  # 过滤空行
        )
        
        # 将处理后的规则存入环境变量
        echo "SYNC_RULES<<EOF" >> $GITHUB_ENV
        echo "$CLEANED_RULES" >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV
        
        # 输出调试信息
        echo "=== 有效同步规则 ==="
        echo "$CLEANED_RULES"

    - name: 配置镜像加速器
      run: |
        echo '{"registry-mirrors": ["https://dockerpull.cn"]}' | sudo tee /etc/docker/daemon.json
        sudo systemctl restart docker

    - name: 登录DockerHub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: 缓存 Docker 层
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    - name: 配置构建环境
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          image=moby/buildkit:latest
          network=host
        buildkitd-config: |
          [registry."docker.io"]
            mirrors = ["dockerpull.cn"]
        cache-from: type=local,src=/tmp/.buildx-cache
        cache-to: type=local,dest=/tmp/.buildx-cache

    - name: 执行镜像处理
      env:
        DOCKERHUB_USER: "${{ secrets.DOCKERHUB_USERNAME }}"
      run: |
        IFS=$'\n'
        # 提前合并拉取所有源镜像
        for rule in $SYNC_RULES; do
          src_image=$(echo "$rule" | cut -d'=' -f1)
          docker pull "$src_image" --quiet || true
        done

        # 执行同步逻辑
        for rule in $SYNC_RULES; do
          [[ -z "$rule" ]] && continue
          echo "=== 处理规则: $rule ==="
          if ! IFS="=" read -r src_image target_part <<< "${rule// /}"; then
            echo "⚠️ 格式错误: $rule"
            continue
          fi

          # 解析目标镜像（原有逻辑）
          if [[ "$target_part" == *":"* ]]; then
            target_tag="${target_part##*:}"
            repo_part="${target_part%:*}"
          else
            target_tag="latest"
            repo_part="$target_part"
          fi

          if [[ "$repo_part" == *"/"* ]]; then
            target_user="${repo_part%%/*}"
            target_image="${repo_part#*/}"
            [[ ! "$target_user" =~ ^[a-z0-9]+([._-][a-z0-9]+)*$ ]] && continue
          else
            target_user="$DOCKERHUB_USER"
            target_image="$repo_part"
          fi

          final_target="${target_user}/${target_image}:${target_tag}"
          [[ ! "$final_target" =~ ^([a-z0-9]+([._-][a-z0-9]+)*/)?[a-z0-9]+([._-][a-z0-9]+)*:[a-zA-Z0-9_.-]+$ ]] && continue

          echo "▷ 源镜像: $src_image → 目标: $final_target"
          echo "🔄 开始同步操作..."
          
          # 验证源镜像可访问性
          if ! docker buildx imagetools inspect "$src_image" >/dev/null 2>&1; then
            echo "❌ 源镜像不可访问: $src_image"
            echo "尝试使用 library/$src_image..."
            if ! docker buildx imagetools inspect "library/$src_image" >/dev/null 2>&1; then
              echo "❌ 镜像仍然不可访问: library/$src_image"
              continue
            else
              src_image="library/$src_image"
            fi
          fi
          
          # 执行多架构镜像同步
          echo "🚀 正在同步多平台镜像..."
          if docker buildx imagetools create -t "$final_target" "$src_image" >/dev/null 2>&1; then
            echo "✅ 同步成功"
            echo "镜像详细信息："
            docker buildx imagetools inspect "$final_target"
          else
            echo "❌ 同步失败，错误详情："
            # 显示完整错误输出
            docker buildx imagetools create -t "$final_target" "$src_image"
          fi
          echo "─────────────────────────────────────"
        done
