name: Image Arch Check and Sync Enhanced

on:
  workflow_dispatch:

jobs:
  check-and-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3  # ç¡®ä¿buildxç¯å¢ƒå¯ç”¨

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo jq

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Process images
        run: |
          set -eo pipefail
          DEST_REPO="${{ secrets.DOCKERHUB_USERNAME }}"

          declare -A SYNC_MAP=(
            ["nginx"]="nginx-m" 
            ["redis:7.0"]="redis:7"
            ["chipsman/uptime-kuma"]="uptime-kuma-back"
            ["chipsman/one-hub"]="one-hub"
          )

          IMAGES=("nginx" "redis:7.0" "chipsman/uptime-kuma" "chipsman/one-hub")

          for source_image in "${IMAGES[@]}"; do
            echo "::group::ğŸ” Processing $source_image"
            
            # ============== è·¯å¾„æ„é€  ==============
            if [[ "$source_image" == *":"* ]]; then
              source_name="${source_image%:*}"
              source_tag="${source_image#*:}"
            else
              source_name="$source_image"
              source_tag="latest"
            fi

            full_source="docker.io/$(
              [[ "$source_name" != *"/"* ]] \
                && echo "library/$source_name" \
                || echo "$source_name"
            ):${source_tag}"

            target_ref="${SYNC_MAP[$source_image]}"
            if [[ -z "$target_ref" ]]; then
              echo "::error::æ‰¾ä¸åˆ°ç›®æ ‡é•œåƒæ˜ å°„"
              exit 1
            fi

            if [[ "$target_ref" == *":"* ]]; then
              target_name="${target_ref%:*}"
              target_tag="${target_ref#*:}"
            else
              target_name="$target_ref"
              target_tag="latest"
            fi
            full_target="docker.io/${DEST_REPO}/${target_name}:${target_tag}"

            # ============== åˆæ­¥éªŒè¯ ==============
            echo "[ç‰ˆæœ¬éªŒè¯]"
            echo "æº: ${full_source}"
            echo "ç›®æ ‡: ${full_target}"
            if ! skopeo inspect "docker://${full_source}" >/dev/null 2>&1; then
              echo "::error::æ— æ³•è®¿é—®æºé•œåƒ"
              exit 1
            fi

            # ============== æ¶æ„æ£€æµ‹ ==============
            echo "ğŸ”„ æ£€æµ‹æ¶æ„ä¿¡æ¯..."
            raw_manifest=$(skopeo inspect --raw "docker://${full_source}" | tee /tmp/manifest.txt)
            is_multiarch=false

            # æ–°çš„åŒé‡åˆ¤å®šé€»è¾‘ï¼ˆå…¼å®¹OCIManifestå’Œmanifest.listï¼‰
            if echo "$raw_manifest" | jq -e '
              (.manifests != null) and
              (
                (.mediaType | contains("manifest.list")) or 
                (.mediaType | contains("vnd.docker.distribution.manifest.list")) or
                (.manifests | length > 0)
              )
            ' >/dev/null; then
              is_multiarch=true
              arch_list=$(echo "$raw_manifest" | jq -r '
                [.manifests[] | 
                  .platform as $p |
                  select($p.os and $p.architecture) |
                  "\($p.os)/\($p.architecture)\($p.variant // "" | if . != "" then "/"+. else "" end)"
                ] | unique | join(", ")
              ')
              echo "âš™ï¸ æ£€æµ‹åˆ°å¤šæ¶æ„é•œåƒ â†’ æ”¯æŒæ¶æ„: [${arch_list}]"
            else
              # å•æ¶æ„é•œåƒè·¯å¾„
              inspect_info=$(skopeo inspect "docker://${full_source}")
              os=$(echo "$inspect_info" | jq -r '.Os // "unknown"')
              arch=$(echo "$inspect_info" | jq -r '.Architecture // "unknown"')
              variant=$(echo "$inspect_info" | jq -r '.Variant? // ""')
              echo "âš™ï¸ å•æ¶æ„é•œåƒ â†’ ${os}/${arch}${variant:+/${variant}}"
            fi

            # ============== é•œåƒåŒæ­¥ ==============
            if [[ "$is_multiarch" == "true" ]]; then
              echo "ğŸš¢ å¤šæ¶æ„é•œåƒåŒæ­¥ â†’ ä½¿ç”¨buildx"
                docker buildx imagetools create -t "$full_target" "$full_source" || {
                echo "::error::buildxåŒæ­¥å¤±è´¥"
                exit 1
              }
            else
              echo "âš¡ å•æ¶æ„é•œåƒåŒæ­¥ â†’ ç›´æ¥æ¨é€"
              docker pull -q "$full_source"
              docker tag "$full_source" "$full_target"
              docker push --quiet "$full_target" || {
                echo "::error::é•œåƒæ¨é€å¤±è´¥"
                exit 1
              }
            fi

            echo "âœ… $source_image åŒæ­¥å®Œæˆ"
            echo "::endgroup::"
          done
