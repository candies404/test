name: Advanced Image Sync

on:
  workflow_dispatch:
    inputs:
      sync_mappings:
        description: 'é•œåƒåŒæ­¥è§„åˆ™ï¼ˆæ ¼å¼ï¼šæºé•œåƒ=ç›®æ ‡é•œåƒï¼Œå¤šä¸ªç”¨é€—å·åˆ†éš”ï¼‰'
        required: false

jobs:
  sync-images:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo

      - name: Validate and process SYNC_MAPPINGS
        id: process-sync-mappings
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          SYNC_MAPPINGS_INPUT: ${{ inputs.sync_mappings || vars.SYNC_MAPPINGS }}
        run: |
          # åŸºç¡€æ ¡éªŒ
          if [ -z "$SYNC_MAPPINGS_INPUT" ]; then
            echo "::error::SYNC_MAPPINGS æœªè®¾ç½®ï¼Œè¯·æä¾›åŒæ­¥è§„åˆ™ã€‚"
            exit 1
          fi

          # åˆå§‹åŒ–å˜é‡
          declare -A processed_rules
          declare -A grouped_rules
          declare -a unique_sources
          IFS=',' read -ra RAW_RULES <<< "${SYNC_MAPPINGS_INPUT//$'\r'/}"  # æ¸…é™¤æ‰€æœ‰å›è½¦ç¬¦

          # å¢å¼ºçš„è§„åˆ™å¤„ç†å‡½æ•°
          process_rule() {
            local source=$(echo "$1" | tr -d '\r' | xargs | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            local target=$(echo "$2" | tr -d '\r' | xargs | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

            # è‡ªåŠ¨è¡¥å…¨æºé•œåƒåç§°
            if [[ "$source" != *"/"* && "$source" != *":"* ]]; then
              source="docker.io/library/$source"
            elif [[ "$source" == *":"* && "$source" != *"/"* ]]; then
              source="docker.io/library/${source/:/:}"
            fi

            # è‡ªåŠ¨ç”Ÿæˆç›®æ ‡é•œåƒåç§°
            if [[ "$target" == *"+USERNAME"* ]]; then
              target="${target//+USERNAME/$DOCKERHUB_USERNAME}"
            fi

            # ä¸¥æ ¼æ ¼å¼æ ¡éªŒ
            if [[ ! "$target" =~ ^[a-z0-9]+([._-][a-z0-9]+)*(/[a-z0-9]+([._-][a-z0-9]+)*)*(:[a-zA-Z0-9_][a-zA-Z0-9_.-]*)?$ ]]; then
              echo "::error::æ— æ•ˆçš„ç›®æ ‡é•œåƒæ ¼å¼: $target"
              exit 1
            fi

            echo "${source}=${target}"
          }

          # å¤„ç†åŸå§‹è§„åˆ™
          for raw_rule in "${RAW_RULES[@]}"; do
            # æ¸…ç†åŸå§‹è§„åˆ™
            rule=$(echo "$raw_rule" | tr -d '\r' | xargs | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            [[ -z "$rule" ]] && continue

            # æ‹†åˆ†æºå’Œç›®æ ‡
            if [[ "$rule" == *"="* ]]; then
              source_part=$(echo "${rule%%=*}" | xargs)
              target_part=$(echo "${rule#*=}" | xargs)
            else
              source_part=$(echo "$rule" | xargs)
              target_part="${DOCKERHUB_USERNAME}/$(echo "$rule" | tr '/' '-' | tr -cd '[:alnum:]._-')-mirror"
            fi

            # å¤„ç†é•œåƒåç§°
            full_rule=$(process_rule "$source_part" "$target_part") || exit 1
            IFS='=' read -r source_image dest_image <<< "$full_rule"

            # æœ‰æ•ˆæ€§æ ¡éªŒ
            if [[ -z "$source_image" || -z "$dest_image" ]]; then
              echo "::warning::å¿½ç•¥æ— æ•ˆè§„åˆ™: $rule"
              continue
            fi

            # å»é‡å¤„ç†
            key="${source_image}=${dest_image}"
            if [[ -n "${processed_rules[$key]}" ]]; then
              continue
            fi
            processed_rules["$key"]=1

            # åˆ†ç»„å¤„ç†
            if [[ -z "${grouped_rules[$dest_image]}" ]]; then
              grouped_rules["$dest_image"]="$source_image"
            else
              grouped_rules["$dest_image"]+=$'\n'"$source_image"
            fi

            # æ”¶é›†æºé•œåƒ
            if [[ ! " ${unique_sources[@]} " =~ " ${source_image} " ]]; then
              unique_sources+=("$source_image")
            fi
          done

          # ç”Ÿæˆåˆ†ç»„JSONï¼ˆä¸¥æ ¼æ¨¡å¼ï¼‰
          grouped_json=$(jq -n '{}')
          for dest in "${!grouped_rules[@]}"; do
            # ä½¿ç”¨æ¢è¡Œç¬¦åˆ†å‰²æºé•œåƒåˆ—è¡¨
            sources=()
            while IFS=$'\n' read -r line; do
              sources+=("$line")
            done <<< "${grouped_rules[$dest]}"

            # ç”Ÿæˆä¸¥æ ¼æ ¼å¼çš„JSONæ•°ç»„
            sources_json=$(printf '%s\n' "${sources[@]}" | jq -R -s 'map(select(. != "" and . != null)) | unique')
            
            grouped_json=$(jq --arg dest "$dest" --argjson sources "$sources_json" '
              . + { ($dest): $sources }
            ' <<< "$grouped_json") || exit 1
          done

          # ç”Ÿæˆå”¯ä¸€æºåˆ—è¡¨ï¼ˆä¸¥æ ¼æ¨¡å¼ï¼‰
          unique_sources_json=$(printf '%s\n' "${unique_sources[@]}" | jq -R -s 'map(select(. != "")) | unique')

          # å®‰å…¨è¾“å‡ºåˆ°GITHUB_OUTPUT
          delimiter=$(openssl rand -hex 16)
          {
            echo "grouped_rules<<${delimiter}"
            jq -c . <<< "$grouped_json"
            echo "${delimiter}"
            
            echo "unique_sources<<${delimiter}"
            jq -c . <<< "$unique_sources_json"
            echo "${delimiter}"
            
            echo "total_rules=${#processed_rules[@]}"
          } >> "$GITHUB_OUTPUT"

      - name: Check architectures
        run: |
          unique_sources=${{ steps.process-sync-mappings.outputs.unique_sources }}
          images=$(echo "$unique_sources" | jq -r 'join(" ")')
          IFS=' ' read -ra IMAGES <<< "$images"

          for image in "${IMAGES[@]}"; do
            echo "å¤„ç†é•œåƒ: $image"
            
            if ! raw_data=$(skopeo inspect --raw "docker://$image" 2>&1); then
              echo "[é”™è¯¯] æ— æ³•è·å–é•œåƒ: $raw_data"
              echo "----------------------------------------"
              continue
            fi

            if echo "$raw_data" | jq -e '.manifests and (.mediaType | contains("manifest.list"))' >/dev/null; then
              archs=$(echo "$raw_data" | jq -r '
                [.manifests[] | 
                .platform as $p |
                select($p.os != null and $p.architecture != null) |
                "\($p.os)/\($p.architecture)" +
                (if $p.variant and $p.variant != "" then "/\($p.variant)" else "" end)
                ] | unique | join(", ")
              ')
              type="å¤šæ¶æ„"
            elif echo "$raw_data" | jq -e '.manifests' >/dev/null; then
              archs=$(echo "$raw_data" | jq -r '
                [.manifests[] | 
                .platform as $p |
                select($p.os != null and $p.architecture != null) |
                "\($p.os)/\($p.architecture)" +
                (if $p.variant and $p.variant != "" then "/\($p.variant)" else "" end)
                ] | unique | join(", ")
              ')
              type="å¤šæ¶æ„"
            else
              inspect_info=$(skopeo inspect "docker://$image")
              os=$(echo "$inspect_info" | jq -r '.Os // "unknown"')
              arch=$(echo "$inspect_info" | jq -r '.Architecture // "unknown"')
              variant=$(echo "$inspect_info" | jq -r '.Variant? // ""')
              if [[ "$os" != "unknown" && "$arch" != "unknown" ]]; then
                archs="${os}/${arch}${variant:+/$variant}"
              else
                archs="<æ— æ•ˆæ¶æ„>"
              fi
              type="å•æ¶æ„"
            fi

            [ "$archs" = "" ] && archs="<æ— æœ‰æ•ˆæ¶æ„>"
            printf "é•œåƒåç§°: %s\næ¶æ„ç±»å‹: %s\næ”¯æŒæ¶æ„: %s\n%s\n" \
              "$image" "$type" "${archs}" "----------------------------------------"
          done

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Sync images
        id: sync-images
        run: |
          # å¢åŠ è°ƒè¯•ä¿¡æ¯è¾“å‡º
          echo "å¤„ç†åçš„åŒæ­¥è§„åˆ™:"
          echo "${{ steps.process-sync-mappings.outputs.grouped_rules }}" | jq .
          
          # ä½¿ç”¨ä¸¥æ ¼çš„JSONè§£æ
          grouped_rules=$(echo '${{ steps.process-sync-mappings.outputs.grouped_rules }}' | jq -c .)
          total_rules=${{ steps.process-sync-mappings.outputs.total_rules }}
          SYNC_EXECUTED=0
          failed_rules=()

          # ä½¿ç”¨jqä¸¥æ ¼è§£æ
          echo "$grouped_rules" | jq -r 'to_entries[] | "\(.key)=\(.value | join(" "))"' | while IFS='=' read -r dest sources; do
            echo "ğŸ”„ æ­£åœ¨åŒæ­¥: $sources â†’ $dest"
            
            # å¢åŠ è¶…æ—¶å’Œé‡è¯•æœºåˆ¶
            if timeout 300 docker buildx imagetools create -t "$dest" $sources; then
              ((SYNC_EXECUTED++))
              echo "âœ… åŒæ­¥æˆåŠŸ: $sources â†’ $dest"
            else
              error_msg="åŒæ­¥å¤±è´¥: $sources â†’ $dest"
              echo "::error::$error_msg"
              failed_rules+=("$error_msg")
            fi
            echo "----------------------------------------"
          done

          # ä¸¥æ ¼å¤„ç†å¤±è´¥è§„åˆ™è¾“å‡º
          failed_rules_json=$(jq -nc '$ARGS.positional' --args "${failed_rules[@]}")
          {
            echo "SYNC_EXECUTED=$SYNC_EXECUTED"
            echo "failed_rules<<EOF"
            echo "$failed_rules_json"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Generate report
        run: |
          total_rules=${{ steps.process-sync-mappings.outputs.total_rules }}
          SYNC_EXECUTED=${{ steps.sync-images.outputs.SYNC_EXECUTED }}
          failed_rules=${{ steps.sync-images.outputs.failed_rules }}

          echo "ğŸ“Š=== åŒæ­¥æŠ¥å‘Š ==="
          echo "ğŸ”¢ å¤„ç†æ€»æ•° | $total_rules"
          echo "ğŸŸ¢ æˆåŠŸåŒæ­¥ | $SYNC_EXECUTED"
          echo "ğŸ”´ åŒæ­¥å¤±è´¥ | $(echo "$failed_rules" | jq 'length')"

          if [ $(echo "$failed_rules" | jq 'length') -gt 0 ]; then
            echo "ğŸ”¥ å¤±è´¥è¯¦æƒ…ï¼š"
            echo "$failed_rules" | jq -r '.[] | "  â€¼ï¸ \(.)"'
            exit 1
          fi
