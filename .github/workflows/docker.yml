name: Image Arch Check and Sync

on:
  workflow_dispatch:

jobs:
  check-and-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y skopeo
          
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Process images
        run: |
          set -eo pipefail  # 增强的错误处理
          DEST_REPO="${{ secrets.DOCKERHUB_USERNAME }}"

          declare -A SYNC_MAP=(
            ["nginx"]="nginx-m"
            ["redis:7.0"]="redis:7"
            ["chipsman/uptime-kuma"]="uptime-kuma-back"
            ["chipsman/one-hub"]="one-hub"
          )
          IMAGES=("nginx" "redis:7.0" "chipsman/uptime-kuma" "chipsman/one-hub")

          for source_image in "${IMAGES[@]}"; do
            echo "::group::Processing $source_image"
            echo "======= [START] Processing: $source_image ======="
            
            # ------------------- 路径构造验证 --------------------
            # 处理源镜像标签
            if [[ "$source_image" == *":"* ]]; then
              source_name="${source_image%:*}"
              source_tag="${source_image#*:}"
            else
              source_name="$source_image"
              source_tag="latest"
            fi

            # 构造完整的源镜像地址
            if [[ "$source_name" != *"/"* ]]; then
              full_source="docker.io/library/${source_name}:${source_tag}"
            else
              full_source="docker.io/${source_name}:${source_tag}"
            fi

            # 处理目标映射
            target_ref="${SYNC_MAP[$source_image]}"
            if [[ -z "$target_ref" ]]; then
              echo "::error::没有找到映射配置: ${source_image}"
              exit 1
            fi

            # 分解目标名称和标签
            if [[ "$target_ref" == *":"* ]]; then
              target_name="${target_ref%:*}"
              target_tag="${target_ref#*:}"
            else
              target_name="$target_ref"
              target_tag="latest"
            fi
            full_target="docker.io/${DEST_REPO}/${target_name}:${target_tag}"

            # 打印路径验证
            echo "[Path Debug]"
            echo "Source Image: $full_source"
            echo "Target Image: $full_target"
            
            # ------------------- 镜像存在性检查 --------------------
            echo "::notice::验证源镜像可访问性..."
            if ! skopeo inspect "docker://${full_source}" >/dev/null 2>&1; then
              echo "::error::源镜像不存在或无法访问: ${full_source}"
              exit 1
            fi

            # ------------------- Manifest检查 --------------------
            echo "::notice::检查镜像架构..."
            raw_manifest=$(skopeo inspect --raw "docker://${full_source}" 2>&1 || {
              echo "::error::获取manifest失败: $?"
              exit 1
            })

            # 检查jq解析结果
            is_multiarch=$(echo "$raw_manifest" | jq -e 'has("manifests")' 2>&1 || {
              echo "::error::jq解析失败: $?"
              echo "原始Manifest片段: ${raw_manifest:0:200}"  # 显示前200字符
              exit 1
            })

            # ------------------- 镜像同步 --------------------
            if [[ "$is_multiarch" == "true" ]]; then
              echo "::notice::发现多架构镜像，使用buildx同步..."
              docker buildx imagetools create -t "$full_target" "$full_source" || {
                echo "::error::buildx同步失败"
                exit 1
              }
            else
              echo "::notice::单架构镜像，直接复制..."
              docker pull "$full_source" || {
                echo "::error::拉取镜像失败"
                exit 1
              }
              docker tag "$full_source" "$full_target" || {
                echo "::error::镜像tag操作失败"
                exit 1
              }
              docker push "$full_target" || {
                echo "::error::推送镜像失败"
                exit 1
              }
            fi

            echo "✅ 成功同步镜像: ${full_source} → ${full_target}"
            echo "======= [END] Processing: $source_image ======="
            echo "::endgroup::"
          done
