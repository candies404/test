name: Image Sync with Architecture Validation

on:
  workflow_dispatch:

jobs:
  image-sync:
    runs-on: ubuntu-latest
    env:
      DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
      DEST_REPO: ${{ secrets.DOCKERHUB_USERNAME }}

    steps:
      - name: Setup build environment
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          driver-opts: network=host

      - name: Install system dependencies
        run: |
          echo "🛠️ Installing required tools..."
          sudo apt-get update && sudo apt-get install -y skopeo jq
          echo "✅ Dependencies installed"

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKERHUB_USER }}
          password: ${{ env.DOCKERHUB_TOKEN }}
        env:
          DOCKER_REGISTRY: index.docker.io

      - name: Execute image synchronization
        run: |
          #!/usr/bin/env bash
          set -euo pipefail

          # 同步配置
          declare -A SYNC_MAP=(
            ['nginx']='nginx-m'
            ['redis:7.0']='redis:7'
            ['chipsman/uptime-kuma']='uptime-kuma-back'
          )

          # 日志颜色定义
          readonly COLOR_RESET="\033[0m"
          readonly COLOR_SRC="\033[1;34m"
          readonly COLOR_DST="\033[1;35m"
          readonly COLOR_OK="\033[1;32m"
          readonly COLOR_WARN="\033[1;33m"
          readonly COLOR_ERR="\033[1;31m"

          # 带时间戳的日志函数（输出到stderr）
          log() {
            local level=$1
            local message=$2
            local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            case $level in
              "INFO")
                echo -e "${COLOR_OK}[${timestamp}] INFO: ${message}${COLOR_RESET}" >&2
                ;;
              "WARN")
                echo -e "${COLOR_WARN}[${timestamp}] WARN: ${message}${COLOR_RESET}" >&2
                ;;
              "ERROR")
                echo -e "${COLOR_ERR}[${timestamp}] ERROR: ${message}${COLOR_RESET}" >&2
                ;;
            esac
          }

          # 镜像路径规范化
          normalize_image() {
            local image_ref=$1
            local default_tag=$2
            local context=$3
            # 分离名称和标签
            if [[ "$image_ref" == *":"* ]]; then
              local image_name="${image_ref%:*}"
              local image_tag="${image_ref#*:}"
            else
              local image_name="$image_ref"
              local image_tag="$default_tag"
            fi
            # 处理不同场景
            case $context in
              "source")
                # 源镜像保留library/前缀
                if [[ "$image_name" == *"/"* ]]; then
                  printf "docker.io/%s:%s" "$image_name" "$image_tag"
                else
                  printf "docker.io/library/%s:%s" "$image_name" "$image_tag"
                fi
                ;;
              "target")
                # 目标镜像使用用户仓库
                printf "docker.io/%s/%s:%s" "$DEST_REPO" "$image_name" "$image_tag"
                ;;
              *)
                log "ERROR" "无效的上下文参数: $context"
                exit 1
                ;;
            esac
          }

          # 架构信息获取
          get_architecture() {
            local image=$1
            log "INFO" "获取架构信息：${COLOR_SRC}${image}${COLOR_RESET}"
            
            # 先尝试检查是否是多架构镜像
            if raw_manifest=$(skopeo inspect --raw --creds "${DOCKERHUB_USER}:${DOCKERHUB_TOKEN}" "docker://${image}" 2>&1) &&
              jq -e '.manifests != null and (.mediaType | contains("manifest.list"))' <<< "$raw_manifest" &>/dev/null; then
              
              # 处理多架构镜像
              local arch_list
              arch_list=$(jq -r '
                [.manifests[].platform |
                  select(.os != "unknown" and .architecture != "unknown") |
                  "\(.os)/\(.architecture)\(if .variant and .variant != "" then "/"+.variant else "" end)"
                ] | unique | join(", ")' <<< "$raw_manifest")
              
              [[ -z "$arch_list" ]] && { log "ERROR" "没有找到有效的架构信息"; return 1; }
              log "INFO" "检测到多架构镜像：${arch_list// /,}"
              echo "$arch_list"
              return 0
            else
              # 单架构或未知类型，使用详细inspect方式
              local inspect_info
              if ! inspect_info=$(skopeo inspect --creds "${DOCKERHUB_USER}:${DOCKERHUB_TOKEN}" "docker://${image}" 2>/dev/null); then
                log "ERROR" "无法获取镜像详细信息"
                return 1
              fi
              # 提取架构信息
              local os
              os=$(jq -r '.Os // "unknown"' <<< "$inspect_info")
              local arch
              arch=$(jq -r '.Architecture // "unknown"' <<< "$inspect_info")
              local variant
              variant=$(jq -r '.Variant? // ""' <<< "$inspect_info")
              
              # 处理无效架构组合
              if [[ "$os" == "unknown" || "$arch" == "unknown" ]]; then
                log "INFO" "单架构镜像：unknown"
                echo "unknown"
                return 0
              fi
              # 格式化输出
              local result="${os}/${arch}"
              [[ -n "$variant" ]] && result+="/${variant}"
              
              # Docker不同版本可能不同字段名，特殊处理
              case "$arch" in
                "arm64")
                  result="linux/arm64/v8"
                  ;;
                "arm")
                  [[ "$variant" == "v7" ]] && result="linux/arm/v7"
                  ;;
              esac
              log "INFO" "单架构镜像：${result}"
              echo "$result"
            fi
          }

          # 镜像同步执行
          sync_image() {
            local src=$1
            local dst=$2
            log "INFO" "启动同步：${COLOR_SRC}${src}${COLOR_RESET} → ${COLOR_DST}${dst}${COLOR_RESET}"
            
            if skopeo inspect --raw --creds "${DOCKERHUB_USER}:${DOCKERHUB_TOKEN}" "docker://${src}" | jq -e '.manifests != null' &>/dev/null; then
              log "INFO" "使用多架构同步模式"
              docker buildx imagetools create -t "$dst" "$src" || { log "ERROR" "多架构同步失败"; return 1; }
            else
              docker pull --quiet "$src" || { log "ERROR" "镜像拉取失败"; return 1; }
              docker tag "$src" "$dst" || { log "ERROR" "镜像标签设置失败"; return 1; }
              docker push --quiet "$dst" || { log "ERROR" "镜像推送失败"; return 1; }
            fi
            log "INFO" "同步完成"
          }

          # 主执行流程
          for source_ref in "${!SYNC_MAP[@]}"; do
            echo "::group::🔄 Processing ${source_ref}"
            # 规范化镜像地址
            src_image=$(normalize_image "$source_ref" "latest" "source")
            dst_ref="${SYNC_MAP[$source_ref]}"
            dst_image=$(normalize_image "$dst_ref" "$(cut -d: -f2 <<< "$src_image")" "target")
            log "INFO" "源镜像地址: ${COLOR_SRC}${src_image}${COLOR_RESET}"
            log "INFO" "目标镜像地址: ${COLOR_DST}${dst_image}${COLOR_RESET}"
            # 验证源镜像
            log "INFO" "验证源镜像可访问性"
            if ! skopeo inspect --creds "${DOCKERHUB_USER}:${DOCKERHUB_TOKEN}" "docker://${src_image}" >/dev/null; then
              log "ERROR" "源镜像不可访问：${src_image}"
              exit 1
            fi
            # 获取目标镜像状态
            if target_info=$(skopeo inspect --creds "${DOCKERHUB_USER}:${DOCKERHUB_TOKEN}" "docker://${dst_image}" 2>/dev/null); then
              dst_exists=true
            else
              dst_exists=false
              log "WARN" "目标镜像不存在，将创建新镜像"
            fi
            # 架构分析
            log "INFO" "执行架构分析"
            src_arch=$(get_architecture "$src_image")
            if $dst_exists; then
              dst_arch=$(get_architecture "$dst_image")
            else
              dst_arch="N/A"
            fi
            # 显示架构对比
            echo -e "\n${COLOR_OK}架构对比报告：${COLOR_RESET}"
            printf "%-40s → %-40s\n" "源架构" "目标架构"
            printf "%-40s │ %-40s\n" "$src_arch" "$dst_arch"
            echo
            # 检查同步必要性
            log "INFO" "计算镜像摘要"
            src_digest=$(skopeo inspect --creds "${DOCKERHUB_USER}:${DOCKERHUB_TOKEN}" --format '{{.Digest}}' "docker://${src_image}")
            
            if $dst_exists && [[ "$(jq -r '.Digest' <<< "$target_info")" == "$src_digest" ]]; then
              log "INFO" "目标镜像已是最新版本，跳过同步"
              echo "::endgroup::"
              continue
            fi
            $dst_exists && log "INFO" "发现差异：源摘要 ${src_digest:0:12}... vs 目标摘要 ${dst_digest:0:12}..."
            if sync_image "$src_image" "$dst_image"; then
              log "INFO" "✅ 同步成功完成"
            else
              log "ERROR" "❌ 同步过程中发生错误"
              exit 1
            fi
            echo "::endgroup::"
          done
