name: Docker é•œåƒåŒæ­¥ä¼˜åŒ–ç‰ˆ

on:
  workflow_dispatch:
    inputs:
      sync_mappings:
        description: 'é•œåƒåŒæ­¥æ˜ å°„ï¼ˆæ ¼å¼ï¼šæºé•œåƒ=ç›®æ ‡é•œåƒï¼Œå¤šä¸ªç”¨é€—å·åˆ†éš”ï¼‰'
        required: false

jobs:
  image-sync:
    name: é•œåƒåŒæ­¥
    runs-on: ubuntu-latest
    env:
      DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
      DEST_REPO: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKER_SYNC_MAPPINGS: ${{ vars.DOCKER_SYNC_MAPPINGS }}
      BUILDKIT_PROGRESS: plain

    steps:
      - name: éªŒè¯é•œåƒåŒæ­¥æ ¼å¼
        id: validate-mappings
        run: |
          if [ -n "${{ github.event.inputs.sync_mappings }}" ]; then
            PROCESSED_MAPPINGS="${{ github.event.inputs.sync_mappings }}"
          else
            PROCESSED_MAPPINGS="$DOCKER_SYNC_MAPPINGS"
          fi

          CLEAN_MAPPINGS=$(echo "$PROCESSED_MAPPINGS" \
            | tr -d '\n' \
            | tr -s ' ' \
            | sed -E -e 's/[[:space:]]//g' \
                     -e 's/,{2,}/,/g' \
                     -e 's/^,//' \
                     -e 's/,$//')

          if [ -z "$CLEAN_MAPPINGS" ]; then
            echo "::error::æœªé…ç½®åŒæ­¥æ˜ å°„"
            exit 1
          fi

          IFS=',' read -r -a MAPPING_PAIRS <<< "$CLEAN_MAPPINGS"
          INVALID_COUNT=0

          for PAIR in "${MAPPING_PAIRS[@]}"; do
            if ! grep -qE '^[^=]+=[^=]+$' <<< "$PAIR"; then
              echo "::error::æ˜ å°„è¯­æ³•é”™è¯¯: '$PAIR' (æ­£ç¡®æ ¼å¼: æºé•œåƒ=ç›®æ ‡é•œåƒ)"
              ((INVALID_COUNT++))
            fi
          done

          [ $INVALID_COUNT -gt 0 ] && exit 1
          echo "SYNC_MAPPINGS=${CLEAN_MAPPINGS}" >> $GITHUB_ENV

      - name: è®¾ç½®å¤šæ¶æ„æ„å»ºç¯å¢ƒ
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          driver-opts: |
            network=host
            image=moby/buildkit:master-rootless
        env:
          DOCKER_CLI_EXPERIMENTAL: enabled

      - name: å®‰è£… skopeo
        run: |
          sudo apt-get update -qq && sudo apt-get install -y skopeo

      - name: ç™»å½• Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKERHUB_USER }}
          password: ${{ env.DOCKERHUB_TOKEN }}

      - name: æ‰§è¡Œé•œåƒåŒæ­¥
        id: sync
        run: |
          #!/usr/bin/env bash
          set -eo pipefail
          shopt -s inherit_errexit

          declare -A LOG_COLORS=([INFO]="\033[1;32m" [WARN]="\033[1;33m" [ERROR]="\033[1;31m")
          log() {
            local level="${1}" message="${2}" timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            echo -e "${LOG_COLORS[$level]}[${timestamp}] ${level}: ${message}\033[0m" >&2
          }

          declare -A SYNC_RESULTS=([TOTAL]=0 [SUCCESS]=0 [SKIPPED]=0 [FAILED]=0)

          process_mapping() {
            local source_ref="${1}" dst_ref="${2}"
            log INFO "ğŸš¦ å¤„ç†æ˜ å°„å¯¹ï¼š${source_ref} â†’ ${dst_ref}"

            # è§„èŒƒåŒ–é•œåƒå¼•ç”¨
            normalize_image() {
              local ref="${1}" default_tag="${2}" context="${3}"
              ref="${ref//${DEST_REPO}\/}" # å»é™¤æ½œåœ¨é‡å¤å‰ç¼€
              
              if [[ "$ref" != *":"* ]]; then
                ref+=":${default_tag}"
              fi
              
              case "$context" in
                "source") 
                  [[ "$ref" != */* ]] && ref="library/${ref}"
                  ;;
                "target")
                  [[ "$ref" != */* ]] && ref="${DEST_REPO}/${ref}"
                  ;;
              esac
              echo "docker.io/${ref}"
            }

            local src_image=$(normalize_image "${source_ref}" "latest" "source")
            local dst_image=$(normalize_image "${dst_ref}" "$(cut -d: -f2 <<< "${src_image}")" "target")

            # å®‰å…¨è·å–æ¶æ„ä¿¡æ¯
            get_architecture() {
              local image="${1}"
              local raw_info=$(skopeo inspect --raw --creds "${DOCKERHUB_USER}:${DOCKERHUB_TOKEN}" "docker://${image}" 2>/dev/null || echo "{}")
              
              # ä½¿ç”¨Heredocç»“æ„ç¡®ä¿è¯­æ³•æ­£ç¡®
              jq -r '
                if .manifests? then
                  [
                    .manifests[].platform |
                    select((.os != "unknown") and (.architecture != "unknown")) |
                    "\(.os)/\(.architecture)" + 
                    (if .variant == "" or .variant == null then "" else "/\(.variant)" end)
                  ] | 
                  unique | 
                  join(",")
                else
                  ( [.Os, .Architecture, .Variant] |
                    map(select(. != "unknown" and . != null)) |
                    if length >= 2 then
                      (
                        .[0] + "/" + .[1] + 
                        (if .[2] then "/\(.[2])" else "" end)
                      )
                    else
                      "æœªæ£€æµ‹å‡ºæ¶æ„ä¿¡æ¯"
                    end
                  )
                end' <<< "${raw_info}"
            }


            # æ¶æ„æ¯”å¯¹é€»è¾‘
            compare_arch() {
              local src_arch=$(get_architecture "${src_image}")
              local dst_arch=""

              if skopeo inspect --creds "${DOCKERHUB_USER}:${DOCKERHUB_TOKEN}" "docker://${dst_image}" &>/dev/null; then
                dst_arch=$(get_architecture "${dst_image}")
                log INFO "ğŸ” æ¶æ„åˆ†æ\næºï¼š${src_arch}\nç›®æ ‡ï¼š${dst_arch}"
                [[ "${src_arch}" == "${dst_arch}" ]] && return 0
              else
                log INFO "âš ï¸ ç›®æ ‡é•œåƒä¸å­˜åœ¨ï¼Œéœ€è¦åŒæ­¥"
              fi
              return 1
            }

            # åŒæ­¥æ§åˆ¶æµç¨‹
            if compare_arch; then
              log INFO "â­ï¸ æ¶æ„ä¸€è‡´ï¼Œè·³è¿‡åŒæ­¥"
              SYNC_RESULTS[SKIPPED]=$((SYNC_RESULTS[SKIPPED]+1))
              return
            fi

            for attempt in {1..3}; do
              log INFO "ğŸ”„ åŒæ­¥å°è¯• #${attempt}"
              if docker buildx imagetools create -t "${dst_image}" "${src_image}"; then
                SYNC_RESULTS[SUCCESS]=$((SYNC_RESULTS[SUCCESS]+1))
                log INFO "âœ… åŒæ­¥æˆåŠŸ"
                return 0
              else
                log WARN "âš ï¸ ç¬¬${attempt}æ¬¡å°è¯•å¤±è´¥"
                sleep $((attempt * 3))
              fi
            done
            
            SYNC_RESULTS[FAILED]=$((SYNC_RESULTS[FAILED]+1))
            log ERROR "âŒ åŒæ­¥å¤±è´¥"
            return 1
          }

          # ä¸»å¤„ç†å¾ªç¯
          IFS=',' read -ra MAPPING_PAIRS <<< "${SYNC_MAPPINGS}"
          SYNC_RESULTS[TOTAL]=${#MAPPING_PAIRS[@]}
          for pair in "${MAPPING_PAIRS[@]}"; do
            IFS='=' read -r src dst <<< "${pair}"
            process_mapping "${src}" "${dst}" || true
          done

          # ç”ŸæˆæŠ¥å‘Š
          echo "NOTIFICATION_CONTENT<<EOF
          ğŸ“Š åŒæ­¥ç»Ÿè®¡
          æ€»æ•°ï¼š${SYNC_RESULTS[TOTAL]}
          âœ… æˆåŠŸï¼š${SYNC_RESULTS[SUCCESS]}
          â© è·³è¿‡ï¼š${SYNC_RESULTS[SKIPPED]}
          âŒ å¤±è´¥ï¼š${SYNC_RESULTS[FAILED]}
          EOF" >> $GITHUB_ENV

      - name: å‘é€é€šçŸ¥
        uses: candies404/Multi-Channel-Notifier@latest
        if: always()
        with:
          title: "é•œåƒåŒæ­¥æŠ¥å‘Š"
          content: ${{ env.NOTIFICATION_CONTENT }}
          wpush_key: ${{ secrets.WPUSH_KEY }}
