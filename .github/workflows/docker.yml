name: Docker 镜像同步优化版

on:
  workflow_dispatch:
    inputs:
      sync_mappings:
        description: '镜像同步映射（格式：源镜像=目标镜像，多个用逗号分隔）'
        required: false

jobs:
  image-sync:
    name: 镜像同步
    runs-on: ubuntu-latest
    env:
      DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
      DEST_REPO: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKER_SYNC_MAPPINGS: ${{ vars.DOCKER_SYNC_MAPPINGS }}
      BUILDKIT_PROGRESS: plain

    steps:
      - name: 验证镜像同步格式
        id: validate-mappings
        run: |
          if [ -n "${{ github.event.inputs.sync_mappings }}" ]; then
            PROCESSED_MAPPINGS="${{ github.event.inputs.sync_mappings }}"
          else
            PROCESSED_MAPPINGS="$DOCKER_SYNC_MAPPINGS"
          fi

          CLEAN_MAPPINGS=$(echo "$PROCESSED_MAPPINGS" \
            | tr -d '\n' \
            | tr -s ' ' \
            | sed -E -e 's/[[:space:]]//g' \
                     -e 's/,{2,}/,/g' \
                     -e 's/^,//' \
                     -e 's/,$//')

          if [ -z "$CLEAN_MAPPINGS" ]; then
            echo "::error::未配置同步映射"
            exit 1
          fi

          IFS=',' read -r -a MAPPING_PAIRS <<< "$CLEAN_MAPPINGS"
          INVALID_COUNT=0

          for PAIR in "${MAPPING_PAIRS[@]}"; do
            if ! grep -qE '^[^=]+=[^=]+$' <<< "$PAIR"; then
              echo "::error::映射语法错误: '$PAIR' (正确格式: 源镜像=目标镜像)"
              ((INVALID_COUNT++))
            fi
          done

          [ $INVALID_COUNT -gt 0 ] && exit 1
          echo "SYNC_MAPPINGS=${CLEAN_MAPPINGS}" >> $GITHUB_ENV

      - name: 设置多架构构建环境
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          driver-opts: |
            network=host
            image=moby/buildkit:master-rootless
        env:
          DOCKER_CLI_EXPERIMENTAL: enabled

      - name: 安装 skopeo
        run: |
          sudo apt-get update -qq && sudo apt-get install -y skopeo

      - name: 登录 Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKERHUB_USER }}
          password: ${{ env.DOCKERHUB_TOKEN }}

      - name: 执行镜像同步
        id: sync
        run: |
          #!/usr/bin/env bash
          set -eo pipefail
          shopt -s inherit_errexit

          declare -A LOG_COLORS=([INFO]="\033[1;32m" [WARN]="\033[1;33m" [ERROR]="\033[1;31m")
          log() {
            local level="${1}" message="${2}" timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            echo -e "${LOG_COLORS[$level]}[${timestamp}] ${level}: ${message}\033[0m" >&2
          }

          declare -A SYNC_RESULTS=([TOTAL]=0 [SUCCESS]=0 [SKIPPED]=0 [FAILED]=0)

          process_mapping() {
            local source_ref="${1}" dst_ref="${2}"
            log INFO "🚦 处理映射对：${source_ref} → ${dst_ref}"

            # 规范化镜像引用
            normalize_image() {
              local ref="${1}" default_tag="${2}" context="${3}"
              ref="${ref//${DEST_REPO}\/}" # 去除潜在重复前缀
              
              if [[ "$ref" != *":"* ]]; then
                ref+=":${default_tag}"
              fi
              
              case "$context" in
                "source") 
                  [[ "$ref" != */* ]] && ref="library/${ref}"
                  ;;
                "target")
                  [[ "$ref" != */* ]] && ref="${DEST_REPO}/${ref}"
                  ;;
              esac
              echo "docker.io/${ref}"
            }

            local src_image=$(normalize_image "${source_ref}" "latest" "source")
            local dst_image=$(normalize_image "${dst_ref}" "$(cut -d: -f2 <<< "${src_image}")" "target")

            # 安全获取架构信息
            get_architecture() {
              local image="${1}"
              local raw_info=$(skopeo inspect --raw --creds "${DOCKERHUB_USER}:${DOCKERHUB_TOKEN}" "docker://${image}" 2>/dev/null || echo "{}")
              
              # 使用Heredoc结构确保语法正确
              jq -r '
                if .manifests? then
                  [
                    .manifests[].platform |
                    select((.os != "unknown") and (.architecture != "unknown")) |
                    "\(.os)/\(.architecture)" + 
                    (if .variant == "" or .variant == null then "" else "/\(.variant)" end)
                  ] | 
                  unique | 
                  join(",")
                else
                  ( [.Os, .Architecture, .Variant] |
                    map(select(. != "unknown" and . != null)) |
                    if length >= 2 then
                      (
                        .[0] + "/" + .[1] + 
                        (if .[2] then "/\(.[2])" else "" end)
                      )
                    else
                      "未检测出架构信息"
                    end
                  )
                end' <<< "${raw_info}"
            }


            # 架构比对逻辑
            compare_arch() {
              local src_arch=$(get_architecture "${src_image}")
              local dst_arch=""

              if skopeo inspect --creds "${DOCKERHUB_USER}:${DOCKERHUB_TOKEN}" "docker://${dst_image}" &>/dev/null; then
                dst_arch=$(get_architecture "${dst_image}")
                log INFO "🔍 架构分析\n源：${src_arch}\n目标：${dst_arch}"
                [[ "${src_arch}" == "${dst_arch}" ]] && return 0
              else
                log INFO "⚠️ 目标镜像不存在，需要同步"
              fi
              return 1
            }

            # 同步控制流程
            if compare_arch; then
              log INFO "⏭️ 架构一致，跳过同步"
              SYNC_RESULTS[SKIPPED]=$((SYNC_RESULTS[SKIPPED]+1))
              return
            fi

            for attempt in {1..3}; do
              log INFO "🔄 同步尝试 #${attempt}"
              if docker buildx imagetools create -t "${dst_image}" "${src_image}"; then
                SYNC_RESULTS[SUCCESS]=$((SYNC_RESULTS[SUCCESS]+1))
                log INFO "✅ 同步成功"
                return 0
              else
                log WARN "⚠️ 第${attempt}次尝试失败"
                sleep $((attempt * 3))
              fi
            done
            
            SYNC_RESULTS[FAILED]=$((SYNC_RESULTS[FAILED]+1))
            log ERROR "❌ 同步失败"
            return 1
          }

          # 主处理循环
          IFS=',' read -ra MAPPING_PAIRS <<< "${SYNC_MAPPINGS}"
          SYNC_RESULTS[TOTAL]=${#MAPPING_PAIRS[@]}
          for pair in "${MAPPING_PAIRS[@]}"; do
            IFS='=' read -r src dst <<< "${pair}"
            process_mapping "${src}" "${dst}" || true
          done

          # 生成报告
          echo "NOTIFICATION_CONTENT<<EOF
          📊 同步统计
          总数：${SYNC_RESULTS[TOTAL]}
          ✅ 成功：${SYNC_RESULTS[SUCCESS]}
          ⏩ 跳过：${SYNC_RESULTS[SKIPPED]}
          ❌ 失败：${SYNC_RESULTS[FAILED]}
          EOF" >> $GITHUB_ENV

      - name: 发送通知
        uses: candies404/Multi-Channel-Notifier@latest
        if: always()
        with:
          title: "镜像同步报告"
          content: ${{ env.NOTIFICATION_CONTENT }}
          wpush_key: ${{ secrets.WPUSH_KEY }}
